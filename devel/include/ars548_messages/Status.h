// Generated by gencpp from file ars548_messages/Status.msg
// DO NOT EDIT!


#ifndef ARS548_MESSAGES_MESSAGE_STATUS_H
#define ARS548_MESSAGES_MESSAGE_STATUS_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace ars548_messages
{
template <class ContainerAllocator>
struct Status_
{
  typedef Status_<ContainerAllocator> Type;

  Status_()
    : timestamp_nanoseconds(0)
    , timestamp_seconds(0)
    , timestamp_syncstatus(0)
    , swversion_major(0)
    , swversion_minor(0)
    , swversion_patch(0)
    , longitudinal(0.0)
    , lateral(0.0)
    , vertical(0.0)
    , yaw(0.0)
    , pitch(0.0)
    , plugorientation(0)
    , length(0.0)
    , width(0.0)
    , height(0.0)
    , wheelbase(0.0)
    , maximundistance(0)
    , frequencyslot(0)
    , cycletime(0)
    , timeslot(0)
    , hcc(0)
    , powersave_standstill(0)
    , sensoripaddress_0(0)
    , sensoripaddress_1(0)
    , configurationcounter(0)
    , status_longitudinalvelocity(0)
    , status_longitudinalacceleration(0)
    , status_lateralacceleration(0)
    , status_yawrate(0)
    , status_steeringangle(0)
    , status_drivingdirection(0)
    , status_characteristicspeed(0)
    , status_radarstatus(0)
    , status_voltagestatus(0)
    , status_temperaturestatus(0)
    , status_blockagestatus(0)  {
    }
  Status_(const ContainerAllocator& _alloc)
    : timestamp_nanoseconds(0)
    , timestamp_seconds(0)
    , timestamp_syncstatus(0)
    , swversion_major(0)
    , swversion_minor(0)
    , swversion_patch(0)
    , longitudinal(0.0)
    , lateral(0.0)
    , vertical(0.0)
    , yaw(0.0)
    , pitch(0.0)
    , plugorientation(0)
    , length(0.0)
    , width(0.0)
    , height(0.0)
    , wheelbase(0.0)
    , maximundistance(0)
    , frequencyslot(0)
    , cycletime(0)
    , timeslot(0)
    , hcc(0)
    , powersave_standstill(0)
    , sensoripaddress_0(0)
    , sensoripaddress_1(0)
    , configurationcounter(0)
    , status_longitudinalvelocity(0)
    , status_longitudinalacceleration(0)
    , status_lateralacceleration(0)
    , status_yawrate(0)
    , status_steeringangle(0)
    , status_drivingdirection(0)
    , status_characteristicspeed(0)
    , status_radarstatus(0)
    , status_voltagestatus(0)
    , status_temperaturestatus(0)
    , status_blockagestatus(0)  {
  (void)_alloc;
    }



   typedef uint32_t _timestamp_nanoseconds_type;
  _timestamp_nanoseconds_type timestamp_nanoseconds;

   typedef uint32_t _timestamp_seconds_type;
  _timestamp_seconds_type timestamp_seconds;

   typedef uint8_t _timestamp_syncstatus_type;
  _timestamp_syncstatus_type timestamp_syncstatus;

   typedef uint8_t _swversion_major_type;
  _swversion_major_type swversion_major;

   typedef uint8_t _swversion_minor_type;
  _swversion_minor_type swversion_minor;

   typedef uint8_t _swversion_patch_type;
  _swversion_patch_type swversion_patch;

   typedef float _longitudinal_type;
  _longitudinal_type longitudinal;

   typedef float _lateral_type;
  _lateral_type lateral;

   typedef float _vertical_type;
  _vertical_type vertical;

   typedef float _yaw_type;
  _yaw_type yaw;

   typedef float _pitch_type;
  _pitch_type pitch;

   typedef uint8_t _plugorientation_type;
  _plugorientation_type plugorientation;

   typedef float _length_type;
  _length_type length;

   typedef float _width_type;
  _width_type width;

   typedef float _height_type;
  _height_type height;

   typedef float _wheelbase_type;
  _wheelbase_type wheelbase;

   typedef uint16_t _maximundistance_type;
  _maximundistance_type maximundistance;

   typedef uint8_t _frequencyslot_type;
  _frequencyslot_type frequencyslot;

   typedef uint8_t _cycletime_type;
  _cycletime_type cycletime;

   typedef uint8_t _timeslot_type;
  _timeslot_type timeslot;

   typedef uint8_t _hcc_type;
  _hcc_type hcc;

   typedef uint8_t _powersave_standstill_type;
  _powersave_standstill_type powersave_standstill;

   typedef uint32_t _sensoripaddress_0_type;
  _sensoripaddress_0_type sensoripaddress_0;

   typedef uint32_t _sensoripaddress_1_type;
  _sensoripaddress_1_type sensoripaddress_1;

   typedef uint8_t _configurationcounter_type;
  _configurationcounter_type configurationcounter;

   typedef uint8_t _status_longitudinalvelocity_type;
  _status_longitudinalvelocity_type status_longitudinalvelocity;

   typedef uint8_t _status_longitudinalacceleration_type;
  _status_longitudinalacceleration_type status_longitudinalacceleration;

   typedef uint8_t _status_lateralacceleration_type;
  _status_lateralacceleration_type status_lateralacceleration;

   typedef uint8_t _status_yawrate_type;
  _status_yawrate_type status_yawrate;

   typedef uint8_t _status_steeringangle_type;
  _status_steeringangle_type status_steeringangle;

   typedef uint8_t _status_drivingdirection_type;
  _status_drivingdirection_type status_drivingdirection;

   typedef uint8_t _status_characteristicspeed_type;
  _status_characteristicspeed_type status_characteristicspeed;

   typedef uint8_t _status_radarstatus_type;
  _status_radarstatus_type status_radarstatus;

   typedef uint8_t _status_voltagestatus_type;
  _status_voltagestatus_type status_voltagestatus;

   typedef uint8_t _status_temperaturestatus_type;
  _status_temperaturestatus_type status_temperaturestatus;

   typedef uint8_t _status_blockagestatus_type;
  _status_blockagestatus_type status_blockagestatus;





  typedef boost::shared_ptr< ::ars548_messages::Status_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::ars548_messages::Status_<ContainerAllocator> const> ConstPtr;

}; // struct Status_

typedef ::ars548_messages::Status_<std::allocator<void> > Status;

typedef boost::shared_ptr< ::ars548_messages::Status > StatusPtr;
typedef boost::shared_ptr< ::ars548_messages::Status const> StatusConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::ars548_messages::Status_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::ars548_messages::Status_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::ars548_messages::Status_<ContainerAllocator1> & lhs, const ::ars548_messages::Status_<ContainerAllocator2> & rhs)
{
  return lhs.timestamp_nanoseconds == rhs.timestamp_nanoseconds &&
    lhs.timestamp_seconds == rhs.timestamp_seconds &&
    lhs.timestamp_syncstatus == rhs.timestamp_syncstatus &&
    lhs.swversion_major == rhs.swversion_major &&
    lhs.swversion_minor == rhs.swversion_minor &&
    lhs.swversion_patch == rhs.swversion_patch &&
    lhs.longitudinal == rhs.longitudinal &&
    lhs.lateral == rhs.lateral &&
    lhs.vertical == rhs.vertical &&
    lhs.yaw == rhs.yaw &&
    lhs.pitch == rhs.pitch &&
    lhs.plugorientation == rhs.plugorientation &&
    lhs.length == rhs.length &&
    lhs.width == rhs.width &&
    lhs.height == rhs.height &&
    lhs.wheelbase == rhs.wheelbase &&
    lhs.maximundistance == rhs.maximundistance &&
    lhs.frequencyslot == rhs.frequencyslot &&
    lhs.cycletime == rhs.cycletime &&
    lhs.timeslot == rhs.timeslot &&
    lhs.hcc == rhs.hcc &&
    lhs.powersave_standstill == rhs.powersave_standstill &&
    lhs.sensoripaddress_0 == rhs.sensoripaddress_0 &&
    lhs.sensoripaddress_1 == rhs.sensoripaddress_1 &&
    lhs.configurationcounter == rhs.configurationcounter &&
    lhs.status_longitudinalvelocity == rhs.status_longitudinalvelocity &&
    lhs.status_longitudinalacceleration == rhs.status_longitudinalacceleration &&
    lhs.status_lateralacceleration == rhs.status_lateralacceleration &&
    lhs.status_yawrate == rhs.status_yawrate &&
    lhs.status_steeringangle == rhs.status_steeringangle &&
    lhs.status_drivingdirection == rhs.status_drivingdirection &&
    lhs.status_characteristicspeed == rhs.status_characteristicspeed &&
    lhs.status_radarstatus == rhs.status_radarstatus &&
    lhs.status_voltagestatus == rhs.status_voltagestatus &&
    lhs.status_temperaturestatus == rhs.status_temperaturestatus &&
    lhs.status_blockagestatus == rhs.status_blockagestatus;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::ars548_messages::Status_<ContainerAllocator1> & lhs, const ::ars548_messages::Status_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace ars548_messages

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::ars548_messages::Status_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ars548_messages::Status_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ars548_messages::Status_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ars548_messages::Status_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ars548_messages::Status_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ars548_messages::Status_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::ars548_messages::Status_<ContainerAllocator> >
{
  static const char* value()
  {
    return "434403d6c9393e6a7279af521716619e";
  }

  static const char* value(const ::ars548_messages::Status_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x434403d6c9393e6aULL;
  static const uint64_t static_value2 = 0x7279af521716619eULL;
};

template<class ContainerAllocator>
struct DataType< ::ars548_messages::Status_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ars548_messages/Status";
  }

  static const char* value(const ::ars548_messages::Status_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::ars548_messages::Status_<ContainerAllocator> >
{
  static const char* value()
  {
    return "uint32 timestamp_nanoseconds #Timestamp Nanoseconds\n"
"uint32 timestamp_seconds #Timestamp Seconds\n"
"uint8 timestamp_syncstatus #Timestamp Sync Status\n"
"uint8 swversion_major #Software version (major)\n"
"uint8 swversion_minor #Software version (minor)\n"
"uint8 swversion_patch #Software version (patch)\n"
"float32 longitudinal #Longitudinal sensor position (AUTOSAR)\n"
"float32 lateral #Lateral sensor position (AUTOSAR)\n"
"float32 vertical #Vertical sensor position (AUTOSAR)\n"
"float32 yaw #Sensor yaw angle (AUTOSAR)\n"
"float32 pitch #Sensor pitch angle (AUTOSAR)\n"
"uint8 plugorientation #Orientation of plug\n"
"float32 length #Vehicle length\n"
"float32 width #Vehicle width\n"
"float32 height #Vehicle height\n"
"float32 wheelbase #Vehicle wheelbase\n"
"uint16 maximundistance #Maximum detection distance\n"
"uint8 frequencyslot #Center frequency\n"
"uint8 cycletime #Cycle time\n"
"uint8 timeslot #Cycle offset\n"
"uint8 hcc #Country code\n"
"uint8 powersave_standstill #Power saving in standstill\n"
"uint32 sensoripaddress_0 #Sensor IP address\n"
"uint32 sensoripaddress_1 #Reserved\n"
"uint8 configurationcounter #Counter that counts up if new configuration has been received and accepted\n"
"uint8 status_longitudinalvelocity #Signals if current VDY is OK or timed out\n"
"uint8 status_longitudinalacceleration #Signals if current VDY is OK or timed out\n"
"uint8 status_lateralacceleration #Signals if current VDY is OK or timed out\n"
"uint8 status_yawrate #Signals if current VDY is OK or timed out\n"
"uint8 status_steeringangle #Signals if current VDY is OK or timed out\n"
"uint8 status_drivingdirection #Signals if current VDY is OK or timed out\n"
"uint8 status_characteristicspeed #(Unused) Signals if current VDY is OK or timed out.\n"
"uint8 status_radarstatus #Signals if Radar Status is OK\n"
"uint8 status_voltagestatus # Bitfield to report under- and overvoltage errors\n"
"uint8 status_temperaturestatus #Bitfield to report under- and overtemperature errors\n"
"uint8 status_blockagestatus #Current blockage state and blockage self test state.\n"
;
  }

  static const char* value(const ::ars548_messages::Status_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::ars548_messages::Status_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.timestamp_nanoseconds);
      stream.next(m.timestamp_seconds);
      stream.next(m.timestamp_syncstatus);
      stream.next(m.swversion_major);
      stream.next(m.swversion_minor);
      stream.next(m.swversion_patch);
      stream.next(m.longitudinal);
      stream.next(m.lateral);
      stream.next(m.vertical);
      stream.next(m.yaw);
      stream.next(m.pitch);
      stream.next(m.plugorientation);
      stream.next(m.length);
      stream.next(m.width);
      stream.next(m.height);
      stream.next(m.wheelbase);
      stream.next(m.maximundistance);
      stream.next(m.frequencyslot);
      stream.next(m.cycletime);
      stream.next(m.timeslot);
      stream.next(m.hcc);
      stream.next(m.powersave_standstill);
      stream.next(m.sensoripaddress_0);
      stream.next(m.sensoripaddress_1);
      stream.next(m.configurationcounter);
      stream.next(m.status_longitudinalvelocity);
      stream.next(m.status_longitudinalacceleration);
      stream.next(m.status_lateralacceleration);
      stream.next(m.status_yawrate);
      stream.next(m.status_steeringangle);
      stream.next(m.status_drivingdirection);
      stream.next(m.status_characteristicspeed);
      stream.next(m.status_radarstatus);
      stream.next(m.status_voltagestatus);
      stream.next(m.status_temperaturestatus);
      stream.next(m.status_blockagestatus);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Status_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::ars548_messages::Status_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::ars548_messages::Status_<ContainerAllocator>& v)
  {
    s << indent << "timestamp_nanoseconds: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.timestamp_nanoseconds);
    s << indent << "timestamp_seconds: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.timestamp_seconds);
    s << indent << "timestamp_syncstatus: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.timestamp_syncstatus);
    s << indent << "swversion_major: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.swversion_major);
    s << indent << "swversion_minor: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.swversion_minor);
    s << indent << "swversion_patch: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.swversion_patch);
    s << indent << "longitudinal: ";
    Printer<float>::stream(s, indent + "  ", v.longitudinal);
    s << indent << "lateral: ";
    Printer<float>::stream(s, indent + "  ", v.lateral);
    s << indent << "vertical: ";
    Printer<float>::stream(s, indent + "  ", v.vertical);
    s << indent << "yaw: ";
    Printer<float>::stream(s, indent + "  ", v.yaw);
    s << indent << "pitch: ";
    Printer<float>::stream(s, indent + "  ", v.pitch);
    s << indent << "plugorientation: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.plugorientation);
    s << indent << "length: ";
    Printer<float>::stream(s, indent + "  ", v.length);
    s << indent << "width: ";
    Printer<float>::stream(s, indent + "  ", v.width);
    s << indent << "height: ";
    Printer<float>::stream(s, indent + "  ", v.height);
    s << indent << "wheelbase: ";
    Printer<float>::stream(s, indent + "  ", v.wheelbase);
    s << indent << "maximundistance: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.maximundistance);
    s << indent << "frequencyslot: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.frequencyslot);
    s << indent << "cycletime: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.cycletime);
    s << indent << "timeslot: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.timeslot);
    s << indent << "hcc: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.hcc);
    s << indent << "powersave_standstill: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.powersave_standstill);
    s << indent << "sensoripaddress_0: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.sensoripaddress_0);
    s << indent << "sensoripaddress_1: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.sensoripaddress_1);
    s << indent << "configurationcounter: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.configurationcounter);
    s << indent << "status_longitudinalvelocity: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.status_longitudinalvelocity);
    s << indent << "status_longitudinalacceleration: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.status_longitudinalacceleration);
    s << indent << "status_lateralacceleration: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.status_lateralacceleration);
    s << indent << "status_yawrate: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.status_yawrate);
    s << indent << "status_steeringangle: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.status_steeringangle);
    s << indent << "status_drivingdirection: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.status_drivingdirection);
    s << indent << "status_characteristicspeed: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.status_characteristicspeed);
    s << indent << "status_radarstatus: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.status_radarstatus);
    s << indent << "status_voltagestatus: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.status_voltagestatus);
    s << indent << "status_temperaturestatus: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.status_temperaturestatus);
    s << indent << "status_blockagestatus: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.status_blockagestatus);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ARS548_MESSAGES_MESSAGE_STATUS_H
